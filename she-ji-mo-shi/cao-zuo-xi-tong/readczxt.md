---
title: 阅读笔记-程序员的自我修养
date: '2017-07-24T21:47:00.000Z'
tags:
  - 阅读笔记
categories:
  - Other
---

# 程序员的自我修养阅读笔记

计算机基础扫盲系列之操作系统 

## 第一章 温故而知新

### 1.2 计算机硬件结构 P6

* 早期，I/O设备和CPU、内存相比还是慢许多，于是每个设置对应一个相应的I/O控制器。
* 后来，CPU核心频率提升，渐渐的CPU、内存等相互跟不上了，于是专门设计了一个高速的**北桥芯片\(Northbridge,PCI Bridge\)**，以便能够在他们之间高速处理数据，像CPU等。
* 但是，如果低速设备也放在北桥上面，那么既要处理高速又要处理低速，会很复杂，于是设计了专门处理低速设备的**南桥\(Southbridge\)**，像磁盘，USB，鼠标等设备都在上面。

### 1.5 内存不够怎么办 P14

如何将有限的物理内存分给多个程序使用，如果采用虚拟内存和物理内存一一对应的方式，会产生下列三种问题。

* 1.地址空间不隔离
* 2.内存使用效率低
* 3.程序的地址不确定

解决:

* 采用**分段**的方式来解决第一个和第三个问题。
* 采用**分页**的方式来解决第二个问题，分页是将地址空间人为地分成固定大小的页，每一页的大小由硬件决定，目前几乎所有的PC上采用4KB大小的页。

常用的数据页和代码----&gt;内存 不常用的数据页和代码-----&gt;磁盘 当进程所需的页不在内存中，又需要的时候，会捕获这个**页错误**，然后操作系统将这个页从磁盘中读出来放在内存中。

### 1.6 线程 P19

* **程序执行的最小单位**，由_线程ID，当前指令指针，寄存器集合和堆栈组成_,各线程之间共享程序的内存空间\(代码、数据段、堆等\)。
* **至少拥有三种状态**，分别是运行，就绪，等待。线程调度主流的方法，都带有**优先级调度**和**轮转法**的痕迹
* 线程依照表现，分为I/O密集型线程\(频繁进入等待，而进入等待会放弃之后任可占用的时间份额\)和CPU密集型线程\(用完全部时间片\)，前者受CPU欢迎。
* 线程优先级的改变份共有三种方式，**用户指定优先级**、**根据进入等待状态的频繁程度提升或降低优先级**、**长时间得不到执行而被提升优先级**

### 1.6.2 线程安全 P24

因为可访问的全局变量和堆数据随时可能被其他的线程改变。当两个线程同时操作一个变量时，既可能发生这种问题。

* 单指令的操作称之为**原子操作**的。在简单的情况，可以使用原子操作，但在复杂的情况就力不从心了
* **二元信号量**，分为占用和非占用两种状态，可以被任意线程获取并释放。
* **互斥量**，和信号量不同的地方在于，那个线程获取的互斥量，那个线程就要负责释放这个锁。
* **临界区**，比互斥量更严格。在信号量和互斥量中，创建后其他进程来获取是合法的。而在临界区中，仅限于本进程，其他进程无法获取。

## 第二章 编译和链接

### 2.1被隐藏了的过程 P38

* **预编译**:处理预编译指令

    gcc -E hello.c -o hello.i

* **编译**:进行一系列词法分析、语法分析、语义分析、优化生成后的汇编代码

    gcc -S hello.i -o hello.s

* **汇编**:将汇编代码转变为机器可以执行的命令

    gcc -c hello.s -o hello.o

* **链接**

### 2.2编译器做了什么 P41

* **词法分析**

    源代码程序被输入到**扫描器**中，扫描器简单的将源代码字符分割成一系列的**记号**。

* **语法分析**

    对**扫描器**中产生的记号进行语法分析，从而产生**语法树**，采用**上下文无关语法**。

* **语义分析**

    语法分析只是从语法层次分析，它并不了解这个语句真正有意义，其中编译器能分析的语义只有**静态语义**\(声明、类型的匹配\)，**动态语意**一般指在运行期出现的相关问题\(0作为除数等\)。

    经过了语义分析阶段以后，整个语法树的表达式都标识了类型。

* **中间语言生成**

    现代的编译器有很多层次的优化，这里所描述的**源码级优化器**在不同编译器中可能有不同的定义。

    源码级优化器往往将语法树转为**中间代码**，是语法树的顺序表示。不同编译器的中间代码有很多类型，常见的有三地址码、P-代码。

    中间代码使编译器可以分为前端和后端。**前端**产生与机器无关的中间代码。**后端**将中间代码转为目标机器代码。

## 3.目标文件里有什么

### 3.1 目标文件的格式

* **可执行文件**格式主要是Windows下的**PE\(Portable Executable\)**和Linux的**ELF\(Executable Linkable Format\)**
* **目标文件**是源代码编译后但是未链接的那些中间文件\(Windows的.obj和Linux下的.o\)

| 可重定位文件 | 包括了代码和数据，可被链接成可执行文件或者共享目标文件 | Linux的.o，Windows的.obj |
| :--- | :--- | :--- |
| 可执行文件 | 可以直接执行的程序，代表就是ELF可执行文件 | bin/bash文件，win的exe |
| 共享目标文件 | 包含了代码和数据，与可重定位文件成新的目标文件，与可执行文件成进程映像 | Linux的.so，Windows的DLL |
| 核心转储文件 | 当进程意外终止，将进程的地址空间内容及终止时的其他信息转为这个 | Linux下的core dump |

EFI文件

* .text section

    程序编译后的机器指令

* .data section

    已初始化的全局变量和局部静态变量

* .bss  section

    为为初始化的全局变量和局部静态变量预留位置

